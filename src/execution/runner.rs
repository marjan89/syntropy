use std::{collections::HashSet, sync::Arc};

use anyhow::{Context, Result, bail, ensure};
use mlua::Lua;
use tokio::sync::Mutex;

use crate::{
    execution::{
        call_item_source_execute, call_item_source_items, call_item_source_preselected_items,
        call_item_source_preview, call_task_execute, call_task_post_run, call_task_pre_run,
        call_task_preview, has_item_source_execute,
    },
    plugins::Task,
};

/// Executes the items pipeline to fetch and prepare items from all item sources.
///
/// This function orchestrates the complete item collection workflow:
///
/// 1. Executes the task's `pre_run` hook (if defined)
/// 2. Validates that the task has at least one item source
/// 3. For each item source, fetches items and preselected items
/// 4. Applies tag prefixing when multiple item sources exist
///
/// # Tag Encoding
///
/// When a task has a single item source, items are returned as-is. When multiple
/// item sources exist, each item is prefixed with `[tag] ` to encode its source.
/// This allows later pipeline stages (preview, execution, post_run) to route items
/// back to their originating source.
///
/// # Arguments
///
/// * `lua` - Thread-safe Lua runtime for executing plugin functions
/// * `task` - The task definition containing item sources and configuration
///
/// # Returns
///
/// Returns a tuple of `(items, preselected_items)` where:
/// - `items` - Combined list of all items from all sources (with tags if multiple sources)
/// - `preselected_items` - Combined list of preselected items (with tags if multiple sources)
///
/// # Errors
///
/// Returns an error if the task has no item sources configured.
pub async fn run_items_pipeline(
    lua: Arc<Mutex<Lua>>,
    task: &Task,
) -> Result<(Vec<String>, Vec<String>)> {
    let Some(item_sources) = &task.item_sources else {
        bail!("No item_sources for task: {}", task.task_key);
    };

    call_task_pre_run(&lua, &task.plugin_name, &task.task_key).await?;

    let mut joined_items = Vec::new();
    let mut joined_preselected_items = Vec::new();

    ensure!(!item_sources.is_empty(), "No items");

    for (item_source_key, item_source) in item_sources {
        let items =
            call_item_source_items(&lua, &task.plugin_name, &task.task_key, item_source_key)
                .await?;
        let preselected_items = call_item_source_preselected_items(
            &lua,
            &task.plugin_name,
            &task.task_key,
            item_source_key,
        )
        .await?;

        if item_sources.len() == 1 {
            joined_items.extend(items);
        } else {
            joined_items.extend(items.iter().map(|s| format!("[{}] {}", item_source.tag, s)));
        }

        if item_sources.len() == 1 {
            joined_preselected_items.extend(preselected_items);
        } else {
            joined_preselected_items.extend(
                preselected_items
                    .iter()
                    .map(|s| format!("[{}] {}", item_source.tag, s)),
            );
        }
    }

    Ok((joined_items, joined_preselected_items))
}

/// Generates a preview for a single item by executing the appropriate preview function.
///
/// This function determines the correct preview source and executes it with fallback logic:
///
/// 1. Identifies the item source that produced the item (via tag matching for multi-source tasks)
/// 2. Attempts to call the item source's `preview()` function
/// 3. Falls back to the task-level `preview()` function if item source preview is unavailable
/// 4. Returns "No preview" if no preview functions are defined
///
/// # Item Source Resolution
///
/// For tasks with a single item source, that source is used directly. For tasks with multiple
/// item sources, the item's `[tag]` prefix is parsed to match it back to its originating source.
///
/// # Arguments
///
/// * `lua` - Thread-safe Lua runtime for executing plugin functions
/// * `task` - The task definition containing item sources and preview functions
/// * `current_item` - The item to preview (may include `[tag]` prefix for multi-source tasks)
///
/// # Returns
///
/// Returns the preview text generated by the item source or task preview function.
///
/// # Errors
///
/// Returns an error if the item source cannot be resolved or if both preview functions fail.
pub async fn run_preview_pipeline(
    lua: Arc<Mutex<Lua>>,
    task: &Task,
    current_item: &str,
) -> Result<String> {
    let Some(item_sources) = &task.item_sources else {
        bail!("No preview available");
    };
    let item_source = if item_sources.len() == 1 {
        item_sources.values().next().context(
            "Plugin declares an item_source, but it's missing. This should never happen.",
        )?
    } else {
        let tag = parse_tag(current_item).0.with_context(|| {
            format!(
                "Item '{}' missing expected tag in multi-source task",
                current_item
            )
        })?;
        item_sources
            .values()
            .find(|item_source| item_source.tag == tag)
            .with_context(|| {
                format!(
                    "Item source for tag {} is missing. This should never happen",
                    tag
                )
            })?
    };

    let item = strip_tag(current_item);

    let preview = call_item_source_preview(
        &lua,
        &task.plugin_name,
        &task.task_key,
        &item_source.item_source_key,
        item,
    )
    .await?;

    let preview = match preview {
        Some(output) => output,
        None => call_task_preview(&lua, &task.plugin_name, &task.task_key, item)
            .await?
            .unwrap_or_else(|| String::from("No preview")),
    };
    Ok(preview)
}

/// Executes the task pipeline for a set of user-selected items.
///
/// This function processes selected items through their appropriate execution handlers:
///
/// 1. For each item source, filters items belonging to that source (via tag matching)
/// 2. Strips tag prefixes from items before execution
/// 3. Calls the item source's `execute()` function, or falls back to task-level `execute()`
/// 4. Collects output from all item sources
/// 5. Executes the task's `post_run` hook (if defined)
///
/// # Execution Model
///
/// Each item source's execution function receives **all selected items** for that source in a
/// single call. The Lua function handles iteration internally, allowing plugins to control
/// error handling and concurrency.
///
/// Item sources are processed sequentially, but each `execute()` function can implement its
/// own concurrency model for processing multiple items.
///
/// # Tag Processing
///
/// For tasks with a single item source, items are used as-is. For multi-source tasks, items
/// are filtered by their `[tag]` prefix and tags are stripped before being passed to the
/// execute function.
///
/// # Arguments
///
/// * `lua` - Thread-safe Lua runtime for executing plugin functions
/// * `task` - The task definition containing item sources and execution functions
/// * `selected_items` - User-selected items to execute (may include `[tag]` prefixes)
///
/// # Returns
///
/// Returns a tuple of `(output, exit_code)` where:
/// - `output` - Combined output from all item source executions, joined with newlines
/// - `exit_code` - First non-zero exit code encountered, or 0 if all executions succeeded
///
/// # Errors
///
/// Returns an error if any execution function fails or if the post_run hook fails.
pub async fn run_execute_pipeline(
    lua: Arc<Mutex<Lua>>,
    task: &Task,
    selected_items: &[String],
) -> Result<(String, i32)> {
    if let Some(item_sources) = &task.item_sources {
        let mut joined_output: Vec<String> = Vec::new();
        let mut final_exit_code = 0;
        for (item_source_key, item_source) in item_sources {
            let mut tags: HashSet<String> = HashSet::default();
            let items: Vec<String> = selected_items
                .iter()
                .filter(|item| {
                    item_sources.len() == 1
                        || item.starts_with(format!("[{}]", item_source.tag).as_str())
                })
                .map(|s| {
                    if item_sources.len() == 1 {
                        s.to_string()
                    } else {
                        let tag = parse_tag(s).0.unwrap_or_default().to_string();
                        tags.insert(tag);
                        strip_tag(s).to_string()
                    }
                })
                .collect();

            if items.is_empty() {
                continue;
            }

            ensure!(
                item_sources.len() == 1 || tags.len() == 1,
                "Failed to parse tag for items of {}",
                item_source_key
            );

            let (output, exit_code) = if has_item_source_execute(&lua, task, item_source_key).await
            {
                if item_sources.len() > 1
                    && let Some(tag) = tags.into_iter().next()
                    && item_source.tag == tag
                {
                    call_item_source_execute(&lua, task, item_source_key, &items).await?
                } else if item_sources.len() == 1 {
                    call_item_source_execute(&lua, task, item_source_key, &items).await?
                } else {
                    continue;
                }
            } else {
                call_task_execute(&lua, task, &items).await?
            };

            joined_output.push(output);

            if final_exit_code == 0 && exit_code != 0 {
                final_exit_code = exit_code;
            }
        }

        call_task_post_run(&lua, &task.plugin_name, &task.task_key).await?;

        let output = joined_output.join("\n");
        if output.is_empty() {
            Ok(("No items were executed".to_string(), 0))
        } else {
            Ok((output, final_exit_code))
        }
    } else {
        call_task_pre_run(&lua, &task.plugin_name, &task.task_key).await?;
        let (output, exit_code) = call_task_execute(&lua, task, &[]).await?;
        call_task_post_run(&lua, &task.plugin_name, &task.task_key).await?;
        Ok((output, exit_code))
    }
}

/// Parses an item string to extract optional tag and content.
///
/// Items can be tagged with `[tag] content` format when multiple item sources are used.
/// Single item sources have no tag prefix.
///
/// # Examples
///
/// ```
/// use syntropy::execution::runner::parse_tag;
///
/// let (tag, content) = parse_tag("[w] Safari - Google");
/// assert_eq!(tag, Some("w"));
/// assert_eq!(content, "Safari - Google");
///
/// let (tag, content) = parse_tag("Spotify");
/// assert_eq!(tag, None);
/// assert_eq!(content, "Spotify");
/// ```
pub fn parse_tag(item: &str) -> (Option<&str>, &str) {
    if let Some(bracket_end) = item.find(']')
        && item.starts_with('[')
    {
        let tag = &item[1..bracket_end];

        if tag.contains(']') || tag.contains('[') {
            return (None, item);
        }

        // Additional validation: check if there's another ] after this one but before a space
        // This catches malformed input like "[a]b] content"
        if bracket_end + 1 < item.len() {
            let after_bracket = &item[bracket_end + 1..];

            // Check the part after ] and before any space
            let part_before_space = if let Some(space_pos) = after_bracket.find(' ') {
                &after_bracket[..space_pos]
            } else {
                after_bracket
            };

            // If this part contains ], it's malformed
            if part_before_space.contains(']') {
                return (None, item);
            }
        }

        // BUG FIX 1: Handle content after bracket intelligently
        if bracket_end + 1 < item.len() {
            let remaining = &item[bracket_end + 1..];

            // If there's a space after ], skip it (remaining content preserved as-is)
            let content = if let Some(stripped) = remaining.strip_prefix(' ') {
                stripped
            } else {
                // No space after ] - use content as-is (no skip)
                remaining
            };

            return (Some(tag), content);
        } else {
            // String ends right after ']' - no content
            return (Some(tag), "");
        }
    }
    (None, item)
}

/// Strips tag prefix from an item string if present.
///
/// Convenience wrapper around `parse_tag` that only returns the content.
///
/// # Examples
///
/// ```
/// use syntropy::execution::runner::strip_tag;
///
/// assert_eq!(strip_tag("[w] Safari - Google"), "Safari - Google");
/// assert_eq!(strip_tag("Spotify"), "Spotify");
/// ```
pub fn strip_tag(item: &str) -> &str {
    parse_tag(item).1
}
